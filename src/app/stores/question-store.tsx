// stores/question-store.tsimport { create } from 'zustand';import { subscribeWithSelector } from 'zustand/middleware';import { immer } from 'zustand/middleware/immer';import { supabase } from '@/lib/supabase';import { QuestionService } from '@/services/supabase-service';import { questionLocalStorageService } from '@/services/question-localStorage-service';import { shouldUseDemoData } from '@/data/demo-data';import type { Question, Answer } from '@/lib/types';import type { RealtimeChannel } from '@supabase/supabase-js';// Enhanced types for better type safetyinterface CreateQuestionData {  subject: string;  topic: string;  type: 'multiple-choice' | 'true-false' | 'calculation' | 'case-study';  difficulty: 'Easy' | 'Medium' | 'Hard';  text: string;  options: Answer[];  explanation: string;  formula?: string;}interface UpdateQuestionData extends Partial<CreateQuestionData> {  id: string;}interface QuestionState {  // State  questions: Question[];  selectedSubject: string;  isLoading: boolean;  error: string | null;  isAuthenticated: boolean | null;  syncStatus: 'idle' | 'syncing' | 'synced' | 'error';  lastSyncTimestamp: number | null;  // Realtime  realtimeChannel: RealtimeChannel | null;  // Actions  setSelectedSubject: (subject: string) => void;  setAuthenticated: (isAuth: boolean | null) => void;  // CRUD Operations  loadQuestions: (subject?: string) => Promise<void>;  createQuestion: (data: CreateQuestionData) => Promise<Question | null>;  updateQuestion: (data: UpdateQuestionData) => Promise<boolean>;  deleteQuestion: (id: string) => Promise<boolean>;  // Sync Management  setupRealtime: () => Promise<void>;  cleanupRealtime: () => void;  syncToCloud: () => Promise<void>;  syncFromCloud: () => Promise<void>;  // Utility  getQuestionsBySubject: (subject: string) => Question[];  clearError: () => void;  reset: () => void;}// Demo questions - Enhanced with more dataconst getDemoQuestions = (): Question[] => [  {    id: 'demo_matematik_001',    subject: 'Matematik',    type: 'multiple-choice',    difficulty: 'Medium',    text: '2x + 5 = 13 denkleminin çözümü nedir?',    options: [      { text: 'x = 4', isCorrect: true },      { text: 'x = 3', isCorrect: false },      { text: 'x = 5', isCorrect: false },      { text: 'x = 6', isCorrect: false },    ],    explanation: 'Denklemde 2x + 5 = 13 ise, her iki taraftan 5 çıkarırsak: 2x = 8, x = 4 bulunur.',    topic: 'Birinci Dereceden Denklemler',    formula: '2x + 5 = 13'  },  {    id: 'demo_matematik_002',    subject: 'Matematik',    type: 'multiple-choice',    difficulty: 'Hard',    text: 'f(x) = x² + 3x - 4 fonksiyonunun kökleri nelerdir?',    options: [      { text: 'x = 1, x = -4', isCorrect: true },      { text: 'x = 2, x = -2', isCorrect: false },      { text: 'x = 4, x = -1', isCorrect: false },      { text: 'x = 3, x = -4', isCorrect: false },    ],    explanation: 'x² + 3x - 4 = 0 denklemini çözmek için: (x - 1)(x + 4) = 0, dolayısıyla x = 1 veya x = -4',    topic: 'İkinci Dereceden Denklemler',    formula: 'x² + 3x - 4 = 0'  },  {    id: 'demo_fizik_001',    subject: 'Fizik',    type: 'multiple-choice',    difficulty: 'Medium',    text: 'Hangi kuvvet türü temas gerektirmez?',    options: [      { text: 'Sürtünme kuvveti', isCorrect: false },      { text: 'Yerçekimi kuvveti', isCorrect: true },      { text: 'Normal kuvvet', isCorrect: false },      { text: 'Elastik kuvvet', isCorrect: false },    ],    explanation: 'Yerçekimi kuvveti uzaktan etki eden bir kuvvettir ve cisimler arasında temas gerektirmez.',    topic: 'Kuvvet ve Hareket',  },  {    id: 'demo_fizik_002',    subject: 'Fizik',    type: 'calculation',    difficulty: 'Hard',    text: '10 kg kütleli bir cisim 5 m/s² ivme ile hareket ediyor. Uygulanan net kuvvet kaç Newton\'dur?',    options: [      { text: '50 N', isCorrect: true },      { text: '15 N', isCorrect: false },      { text: '2 N', isCorrect: false },      { text: '0.5 N', isCorrect: false },    ],    explanation: 'Newton\'un 2. yasasına göre: F = m × a = 10 kg × 5 m/s² = 50 N',    topic: 'Newton Yasaları',    formula: 'F = m × a'  },  {    id: 'demo_kimya_001',    subject: 'Kimya',    type: 'multiple-choice',    difficulty: 'Easy',    text: 'Suyun kimyasal formülü nedir?',    options: [      { text: 'H2O', isCorrect: true },      { text: 'H2O2', isCorrect: false },      { text: 'HO2', isCorrect: false },      { text: 'H3O', isCorrect: false },    ],    explanation: 'Su molekülü 2 hidrojen ve 1 oksijen atomundan oluşur: H2O',    topic: 'Temel Kimyasal Formüller',  }];export const useQuestionStore = create<QuestionState>()(  subscribeWithSelector(    immer((set, get) => ({      // Initial State      questions: [],      selectedSubject: '',      isLoading: false,      error: null,      isAuthenticated: null,      syncStatus: 'idle',      lastSyncTimestamp: null,      realtimeChannel: null,      // Actions      setSelectedSubject: (subject: string) => {        set((state) => {          state.selectedSubject = subject;        });        // Auto-load questions when subject changes        get().loadQuestions(subject);      },      setAuthenticated: (isAuth: boolean | null) => {        set((state) => {          state.isAuthenticated = isAuth;        });        // Handle auth state changes        if (isAuth) {          get().setupRealtime();          get().syncFromCloud();        } else {          get().cleanupRealtime();        }      },      // Enhanced CRUD Operations with automatic sync      loadQuestions: async (subject?: string) => {        const targetSubject = subject || get().selectedSubject;        if (!targetSubject) {          set((state) => {            state.questions = [];            state.isLoading = false;          });          return;        }        set((state) => {          state.isLoading = true;          state.error = null;        });        try {          let loadedQuestions: Question[] = [];          // Demo mode: Return demo + localStorage questions          if (shouldUseDemoData()) {            const demoQuestions = getDemoQuestions().filter(q => q.subject === targetSubject);            const localQuestions = await questionLocalStorageService.getQuestionsBySubject(targetSubject);            loadedQuestions = [...demoQuestions, ...localQuestions];          } else {            // Check authentication            const { data: { session } } = await supabase.auth.getSession();            if (!session || !get().isAuthenticated) {              // No session: localStorage only              loadedQuestions = await questionLocalStorageService.getQuestionsBySubject(targetSubject);            } else {              // Has session: Try Supabase first, fallback to localStorage              try {                const supabaseQuestions = await QuestionService.getQuestionsBySubject(targetSubject);                loadedQuestions = supabaseQuestions.map(mapSupabaseToQuestion);                // Sync to localStorage for offline access                const allLocalQuestions = await questionLocalStorageService.getAllQuestions();                const filteredLocal = allLocalQuestions.filter((q: Question) => q.subject !== targetSubject);                await questionLocalStorageService.saveQuestionsToStorage([...filteredLocal, ...loadedQuestions]);                set((state) => {                  state.syncStatus = 'synced';                  state.lastSyncTimestamp = Date.now();                });              } catch (cloudError) {                console.warn('Cloud fetch failed, using localStorage:', cloudError);                loadedQuestions = await questionLocalStorageService.getQuestionsBySubject(targetSubject);                set((state) => {                  state.syncStatus = 'error';                });              }            }          }          set((state) => {            state.questions = loadedQuestions;            state.isLoading = false;            state.error = null;          });        } catch (error) {          console.error('Failed to load questions:', error);          set((state) => {            state.error = 'Sorular yüklenirken hata oluştu';            state.isLoading = false;            state.syncStatus = 'error';          });        }      },      createQuestion: async (data: CreateQuestionData): Promise<Question | null> => {        set((state) => {          state.syncStatus = 'syncing';        });        try {          const newQuestion: Question = {            id: `q_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,            ...data,          };          // Demo mode or no auth: localStorage only          if (shouldUseDemoData() || !get().isAuthenticated) {            const localQuestion = questionLocalStorageService.addQuestion(data);            // Add to current state if it matches selected subject            if (data.subject === get().selectedSubject) {              set((state) => {                state.questions.unshift(localQuestion);                state.syncStatus = 'synced';              });            }            return localQuestion;          }          // Try cloud first          const { data: { session } } = await supabase.auth.getSession();          if (session) {            try {              // Create in Supabase              const supabaseQuestion = await QuestionService.createQuestion({                subject_id: '', // You might need to get this from subjects                subject: data.subject,                topic: data.topic,                type: data.type,                difficulty: data.difficulty,                text: data.text,                options: JSON.stringify(data.options),                correct_answer: data.options.find(opt => opt.isCorrect)?.text || '',                explanation: data.explanation,                formula: data.formula || '',                is_active: true,              });              if (supabaseQuestion) {                const mappedQuestion = mapSupabaseToQuestion(supabaseQuestion);                // Add to localStorage for sync                questionLocalStorageService.addQuestion(data);                // Add to state if matches selected subject                if (data.subject === get().selectedSubject) {                  set((state) => {                    state.questions.unshift(mappedQuestion);                    state.syncStatus = 'synced';                    state.lastSyncTimestamp = Date.now();                  });                }                return mappedQuestion;              }            } catch (cloudError) {              console.warn('Cloud create failed, using localStorage:', cloudError);            }          }          // Fallback to localStorage          const localQuestion = questionLocalStorageService.addQuestion(data);          if (data.subject === get().selectedSubject) {            set((state) => {              state.questions.unshift(localQuestion);              state.syncStatus = 'synced';            });          }          return localQuestion;        } catch (error) {          console.error('Failed to create question:', error);          set((state) => {            state.error = 'Soru oluşturulurken hata oluştu';            state.syncStatus = 'error';          });          return null;        }      },      updateQuestion: async (data: UpdateQuestionData): Promise<boolean> => {        set((state) => {          state.syncStatus = 'syncing';        });        try {          // Demo mode or no auth: localStorage only          if (shouldUseDemoData() || !get().isAuthenticated) {            const success = questionLocalStorageService.updateQuestion(data.id, data);            if (success) {              set((state) => {                const index = state.questions.findIndex(q => q.id === data.id);                if (index !== -1 && state.questions[index]) {                  Object.assign(state.questions[index], data);                }                state.syncStatus = 'synced';              });            }            return success;          }          // Try cloud first          const { data: { session } } = await supabase.auth.getSession();          if (session) {            try {              const updateData: Partial<CreateQuestionData> = { ...data };              if (data.options) {                updateData.options = JSON.stringify(data.options);                updateData.correct_answer = data.options.find(opt => opt.isCorrect)?.text || '';              }              delete updateData.id;              const success = await QuestionService.updateQuestion(data.id, updateData);              if (success) {                // Update localStorage                questionLocalStorageService.updateQuestion(data.id, data);                // Update state                set((state) => {                  const index = state.questions.findIndex(q => q.id === data.id);                  if (index !== -1 && state.questions[index]) {                    Object.assign(state.questions[index], data);                  }                  state.syncStatus = 'synced';                  state.lastSyncTimestamp = Date.now();                });                return true;              }            } catch (cloudError) {              console.warn('Cloud update failed, using localStorage:', cloudError);            }          }          // Fallback to localStorage          const success = questionLocalStorageService.updateQuestion(data.id, data);          if (success) {            set((state) => {              const index = state.questions.findIndex(q => q.id === data.id);              if (index !== -1 && state.questions[index]) {                Object.assign(state.questions[index], data);              }              state.syncStatus = 'synced';            });          }          return success;        } catch (error) {          console.error('Failed to update question:', error);          set((state) => {            state.error = 'Soru güncellenirken hata oluştu';            state.syncStatus = 'error';          });          return false;        }      },      deleteQuestion: async (id: string): Promise<boolean> => {        set((state) => {          state.syncStatus = 'syncing';        });        try {          // Demo mode or no auth: localStorage only          if (shouldUseDemoData() || !get().isAuthenticated) {            const success = questionLocalStorageService.deleteQuestion(id);            if (success) {              set((state) => {                state.questions = state.questions.filter(q => q.id !== id);                state.syncStatus = 'synced';              });            }            return success;          }          // Try cloud first          const { data: { session } } = await supabase.auth.getSession();          if (session) {            try {              const success = await QuestionService.deleteQuestion(id);              if (success) {                // Delete from localStorage                questionLocalStorageService.deleteQuestion(id);                // Update state                set((state) => {                  state.questions = state.questions.filter(q => q.id !== id);                  state.syncStatus = 'synced';                  state.lastSyncTimestamp = Date.now();                });                return true;              }            } catch (cloudError) {              console.warn('Cloud delete failed, using localStorage:', cloudError);            }          }          // Fallback to localStorage          const success = questionLocalStorageService.deleteQuestion(id);          if (success) {            set((state) => {              state.questions = state.questions.filter(q => q.id !== id);              state.syncStatus = 'synced';            });          }          return success;        } catch (error) {          console.error('Failed to delete question:', error);          set((state) => {            state.error = 'Soru silinirken hata oluştu';            state.syncStatus = 'error';          });          return false;        }      },      // Realtime Management      setupRealtime: async () => {        if (!get().isAuthenticated || shouldUseDemoData()) {          return;        }        try {          const { data: { session } } = await supabase.auth.getSession();          if (!session) return;          // Cleanup existing channel          get().cleanupRealtime();          // Create new realtime channel          const channel = supabase            .channel(`questions-${session.user.id}`)            .on(              'postgres_changes',              {                event: '*',                schema: 'public',                table: 'questions',                filter: `created_by=eq.${session.user.id}`,              },              (payload) => {                handleRealtimeChange(payload, get, set);              }            )            .subscribe();          set((state) => {            state.realtimeChannel = channel;          });        } catch (error) {          console.error('Realtime setup failed:', error);          set((state) => {            state.error = 'Realtime bağlantı kurulurken hata oluştu';          });        }      },      cleanupRealtime: () => {        const channel = get().realtimeChannel;        if (channel) {          supabase.removeChannel(channel);          set((state) => {            state.realtimeChannel = null;          });        }      },      // Sync Management      syncToCloud: async () => {        if (!get().isAuthenticated || shouldUseDemoData()) {          return;        }        set((state) => {          state.syncStatus = 'syncing';        });        try {          const localQuestions = questionLocalStorageService.getQuestions();          // Implementation for syncing local questions to cloud          // This would be a complex operation involving conflict resolution          set((state) => {            state.syncStatus = 'synced';            state.lastSyncTimestamp = Date.now();          });        } catch (error) {          console.error('Sync to cloud failed:', error);          set((state) => {            state.syncStatus = 'error';          });        }      },      syncFromCloud: async () => {        if (!get().isAuthenticated || shouldUseDemoData()) {          return;        }        await get().loadQuestions();      },      // Utility functions      getQuestionsBySubject: (subject: string) => {        return get().questions.filter(q => q.subject === subject);      },      clearError: () => {        set((state) => {          state.error = null;        });      },      reset: () => {        get().cleanupRealtime();        set((state) => {          state.questions = [];          state.selectedSubject = '';          state.isLoading = false;          state.error = null;          state.syncStatus = 'idle';          state.lastSyncTimestamp = null;          state.realtimeChannel = null;        });      },    }))  ));// Enhanced realtime change handlerinterface RealtimePayload {  eventType: 'INSERT' | 'UPDATE' | 'DELETE';  new?: Record<string, any>;  old?: Record<string, any>;}function handleRealtimeChange(  payload: RealtimePayload,  get: () => QuestionState,  set: (fn: (state: QuestionState) => void) => void) {  const { eventType, new: newRecord, old: oldRecord } = payload;  const { selectedSubject } = get();  switch (eventType) {    case 'INSERT':      if (newRecord && newRecord.subject === selectedSubject) {        const newQuestion = mapSupabaseToQuestion(newRecord);        set((state) => {          // Prevent duplicates          if (!state.questions.find(q => q.id === newQuestion.id)) {            state.questions.unshift(newQuestion);          }          state.lastSyncTimestamp = Date.now();        });        // Sync to localStorage        questionLocalStorageService.addQuestion(newQuestion);      }      break;    case 'UPDATE':      if (newRecord) {        const updatedQuestion = mapSupabaseToQuestion(newRecord);        set((state) => {          const index = state.questions.findIndex(q => q.id === updatedQuestion.id);          // If subject changed and no longer matches, remove it          if (newRecord.subject !== selectedSubject) {            if (index !== -1) {              state.questions.splice(index, 1);            }          } else {            // Update or add the question            if (index !== -1) {              state.questions[index] = updatedQuestion;            } else {              state.questions.unshift(updatedQuestion);            }          }          state.lastSyncTimestamp = Date.now();        });        // Sync to localStorage        questionLocalStorageService.updateQuestion(updatedQuestion.id, updatedQuestion);      }      break;    case 'DELETE':      if (oldRecord) {        set((state) => {          state.questions = state.questions.filter(q => q.id !== oldRecord.id);          state.lastSyncTimestamp = Date.now();        });        // Sync to localStorage        questionLocalStorageService.deleteQuestion(oldRecord.id);      }      break;  }}// Helper function to map Supabase record to Questionfunction mapSupabaseToQuestion(record: Record<string, any>): Question {  return {    id: record.id,    subject: record.subject,    type: record.type as 'multiple-choice' | 'true-false' | 'calculation' | 'case-study',    difficulty: record.difficulty as 'Easy' | 'Medium' | 'Hard',    text: record.text,    options: JSON.parse(record.options || '[]'),    explanation: record.explanation,    topic: record.topic || '',    formula: record.formula || '',  };}// Auth state subscription to automatically handle auth changessupabase.auth.onAuthStateChange((event, session) => {  const store = useQuestionStore.getState();  if (event === 'SIGNED_IN') {    store.setAuthenticated(true);  } else if (event === 'SIGNED_OUT') {    store.setAuthenticated(false);  }});
